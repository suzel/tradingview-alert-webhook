//@version=4
strategy("My Strategy", overlay=true, margin_long=100, margin_short=100)


long_tp_inp = input(100, title="Long Take Profit %", step=0.1) / 100
price = strategy.position_avg_price * (1 + long_tp_inp)
plot(price)


if bar_index == 1
    strategy.entry ("LONG", true)

strategy.exit("EXIT", "LONG", limit =   price)

//-----------------------------------------------------------------------------

// Execute trade if condition is True
// if (longCondition)
//     stopLoss = low - atr * 2
//     takeProfit = high + atr * 2
//     strategy.entry("long", strategy.long, 100, when = rsi > 50)
//     strategy.exit("exit", "long", stop=stopLoss, limit=takeProfit)

// if (shortCondition)
//     stopLoss = high + atr * 2
//     takeProfit = low - atr * 2
//     strategy.entry("short", strategy.short, 100, when = rsi < 50)
//     strategy.exit("exit", "short", stop=stopLoss, limit=takeProfit)

//-----------------------------------------------------------------------------

start_date = input(title="Start Date", type=input.integer, defval=4, minval=1, maxval=31)
start_month = input(title="Start Month", type=input.integer, defval=9, minval=1, maxval=12)
start_year = input(title="Start Year", type=input.integer, defval=2020)
end_date = input(title="End Date", type=input.integer, defval=6, minval=1, maxval=31)
end_month = input(title="End Month", type=input.integer, defval=9, minval=1, maxval=12)
end_year = input(title="End Year", type=input.integer, defval=2020)

between_dates = (time >= timestamp(start_year, start_month, start_date, 7, 0)) and (time < timestamp(end_year, end_month, end_date, 23, 59))

if between_dates
    strategy.entry("doge door", strategy.long, when=buy_condition)

//-----------------------------------------------------------------------------

// ---------------- ORDER MANAGEMENT FUNCTIONS ----------------
// strategy.entry()
// strategy.order()
// strategy.exit()
// strategy.close()
// strategy.close_all()
// strategy.cancel()
// strategy.cancel_all()


// ---------------- ORDER MANAGEMENT FUNCTIONS SYNTAX ----------------
// All Arguments
// strategy.entry(id, long, qty, limit, stop, oca_name, oca_type, comment, when, alert_message) â†’ void
// strategy.order(id, long, qty, limit, stop, oca_name, oca_type, comment, when, alert_message) â†’ void
// strategy.exit(id, from_entry, qty, qty_percent, profit, limit, loss, stop, trail_price, trail_points, trail_offset, oca_name, comment, when, alert_message) â†’ void
// strategy.close(id, when, comment, qty, qty_percent, alert_message) â†’ void
// strategy.close_all(when, comment, alert_message) â†’ void
// strategy.cancel(id, when) â†’ void
// strategy.cancel_all(when) â†’ void

// Minimum Required Arguments
// strategy.entry(id, long)
// strategy.order(id, long)
// strategy.exit(id)
// strategy.close(id)
// strategy.close_all()
// strategy.cancel(id)
// strategy.cancel_all()

// ğŸ“ Note: The id argument is required for almost all of the functions.


// ----- CODE -----
strategy("Order Types", overlay=true, pyramiding=1)

// Input Settings
rsiLength   = input( 14 )
overSold    = input( 30 )
overBought  = input( 70 )

// Strategy
rsi         = rsi(close, rsiLength)
goLong      = rsi < overSold
goShort     = rsi > overBought

//      ğŸ“ˆğŸ“ˆğŸ“ˆ     Quickstart Example 1    ğŸ“ˆğŸ“ˆğŸ“ˆ
if goLong
	strategy.entry(id="goLong", long=strategy.long)

if goShort
	strategy.entry(id="goShort", long=strategy.short)
//      ğŸ“‰ğŸ“‰ğŸ“‰                             ğŸ“‰ğŸ“‰ğŸ“‰



// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
//  ğŸ¹ WHAT'S THE DIFFERENCE BETWEEN strategy.order() AND strategy.entry()?
// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥


// â–²â–² strategy.entry() is affected by the pyramiding setting in the strategy's properties
// ğŸš« strategy.entry() is affected by the strategy.risk.allow_entry_in function
// ğŸ”ƒ strategy.entry() can reverse positions long/short


// Run these commands separately and mess with the pyramiding setting to see the effect.
// The pyramiding setting can be found in the properties tab of the strategy on the chart
// Or, can be programmed in the strategy() annotation as an argument.
//     ğŸ“ˆğŸ“ˆğŸ“ˆ           PYRAMIDING             ğŸ“ˆğŸ“ˆğŸ“ˆ
// ğŸ‘‡ Pyramiding has an effect
// strategy.entry(id="Go Long", long=true, when=goLong)
// ğŸ‘†

// ğŸ‘‡ Pyramiding Has No Effect.
// strategy.order(id="Go Long", long=true, when=goLong)
// ğŸ‘†

//     ğŸ“‰ğŸ“‰ğŸ“‰                                  ğŸ“‰ğŸ“‰ğŸ“‰

// We can also test the effect of strategy.risk.allow_entry_in() function on strategy.entry and strategy.order
// ğŸ“ Note: These have no effect on the strategy.order() function
//     ğŸ“ˆğŸ“ˆğŸ“ˆ           strategy.risk.allow_entry_in()             ğŸ“ˆğŸ“ˆğŸ“ˆ
// strategy.risk.allow_entry_in(strategy.direction.all)    // This is the default

// ğŸ‘‡ Only Go Long.
// strategy.risk.allow_entry_in(strategy.direction.long)
// ğŸ‘†

// ğŸ‘‡ Only Go Short.
// strategy.risk.allow_entry_in(strategy.direction.short)
// ğŸ‘†

// strategy.entry(id="Go Long",  long=false)
// OR
// strategy.order(id="Go Long", long=true)
//     ğŸ“‰ğŸ“‰ğŸ“‰                                                      ğŸ“‰ğŸ“‰ğŸ“‰


//     ğŸ“ˆğŸ“ˆğŸ“ˆ           POSITION REVERSALS              ğŸ“ˆğŸ“ˆğŸ“ˆ
// ğŸ“Œ Run these two together and notice the reversal.
// strategy.entry(id="Go Long", long=true, when=goLong)
// strategy.entry(id="Go Short", long=false, when=goShort)

// ğŸ“Œ Run these two together and notice the orders just keep stacking up.
// strategy.order(id="Go Long", long=true, when=goLong)
// strategy.order(id="Go Short", long=false, when=goShort)

// ğŸ“Œ If you run entry() and order() together, positions opened from order() can be reversed from entry()
// ğŸ“ Note: By default the size of each order is 1 contract. We can change this with the "qty" argument.
// if goShort
//     strategy.order(id="Go Short", long=false, qty=10)      // Open 10 contracts short on signal.

// if goLong
    // strategy.entry(id="Go Long", long=true, qty=10)         // Open 10 contract long on signal.
// ğŸ“Œ Notice how we open up more than 10 contracts when going long. This is because the entire position is reveresed.

//     ğŸ“‰ğŸ“‰ğŸ“‰                                           ğŸ“‰ğŸ“‰ğŸ“‰


// â“Which one should you useâ“
// Whichever one works for you really.
// But generally, it's easier to work with strategy.entry so stick with that if your'e just starting out.

//   ğŸ¯




// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
// ğŸ¹ How to Exit a Trade using strategy market orders with strategy.close and strategy.close_all
// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥

// We may not want to flip from long to short positions in our strategy. Sometimes we might just want to exit a position completely
// wait for the next signal to get back in. This is where exits come in.

// ğŸš® strategy.close() function closes a particular entry trade with fully or partially with a market order.
// ğŸš® strategy.close_all() function closes all positions with a market order.
// ğŸ“ Note: These functions do nothing if there are no open orders.

//     ğŸ“ˆğŸ“ˆğŸ“ˆ   MARKET EXIT A POSITION SPAWNED FROM A SPECIFIC ID    ğŸ“ˆğŸ“ˆğŸ“ˆ
// strategy.entry(id="Go Long", long=true, when=goLong)   // Entry order from strategy.entry
// strategy.close(id="Go Long", when=goShort)             // Close all orders spawned from this ID
// OR
// strategy.order(id="Go Long", long=true, when=goLong)   // Entry order from strategy.order
// strategy.close(id="Go Long", when=goShort)             // Close all orders spawned from this ID
//     ğŸ“‰ğŸ“‰ğŸ“‰                                                        ğŸ“‰ğŸ“‰ğŸ“‰


//     ğŸ“ˆğŸ“ˆğŸ“ˆ   MARKET EXIT ALL POSITIONS   ğŸ“ˆğŸ“ˆğŸ“ˆ
// strategy.entry(id="Go Long Entry 1", long=true, when=goLong)    // Entry order from strategy.entry
// strategy.entry(id="Go Long Entry 2", long=true, when=goLong)    // Entry order from strategy.entry
// strategy.order(id="Go Long Order 1", long=true, when=goLong)    // Entry order from strategy.order
// strategy.order(id="Go Long Order 2", long=true, when=goLong)    // Entry order from strategy.order
// strategy.close_all(when=goShort)                                // Close all orders regardless of ID
//     ğŸ“‰ğŸ“‰ğŸ“‰                               ğŸ“‰ğŸ“‰ğŸ“‰


//     ğŸ“ˆğŸ“ˆğŸ“ˆ   PARTIALLY MARKET EXIT A POSITION SPAWNED FROM A SPECIFIC ID    ğŸ“ˆğŸ“ˆğŸ“ˆ
// strategy.entry(id="Go Long", long=true, when=goLong)                   // Entry order from strategy.entry

// ğŸ‘‡ Method 1: Close all orders spawned from this ID, by 1 unit
// strategy.close(id="Go Long", when=goShort, qty=1)
// // ğŸ“ Note: "qty" is the number of contracts/shares/lots/units to exit a trade with. It is not the same as the default_qty_type found in the strategy() annotation
// ğŸ‘†

// ğŸ‘‡ Method 2: Close all orders spawned from this ID, by 10%
// strategy.close(id="Go Long", when=goShort, qty_percent=10)
// // ğŸ“ Note: Percentage is based off the remaining position size. So 10% ten times won't fully reduce a position 100%.
// ğŸ‘†

// ğŸ‘‡ Method 3: Close all orders spawned from this ID, by 1 unit
// strategy.close(id="Go Long", when=goShort, qty=1, qty_percent=10)
// // ğŸ“ Note: The docs mention that "qty_percent" take priority over "qty" argument, but this is actually the opposite.
// ğŸ‘†

// We can check the effect of these exits by plotting our position size and visualizing the changes.
// plot(strategy.position_size)
//     ğŸ“‰ğŸ“‰ğŸ“‰                                                        ğŸ“‰ğŸ“‰ğŸ“‰

//   ğŸ¯




// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
// ğŸ¹                    How to Place a Limit Entry Order
// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥

// Our two functions for placing market orders can also place limit orders.
// strategy.entry(id, long, limit=limitPrice)
// strategy.order(id, long, limit=limitPrice)

// We can do this by setting the "limit" argument to a correct limit price

// For a buy limit we want the limit price to be lower than the current price
// For a sell limit we want the limit price to be higher than the curent price.

//     ğŸ“ˆğŸ“ˆğŸ“ˆ   LIMIT ENTRY: strategy.entry()    ğŸ“ˆğŸ“ˆğŸ“ˆ
// strategy.entry("Buy Limit",  long=true,  limit=low,  when=goLong)       // Buy Limit set at the low of signal.
// strategy.entry("Sell Limit", long=false, limit=high, when=goShort)      // Sell Limit set at the high of signal.
//     ğŸ“‰ğŸ“‰ğŸ“‰                                    ğŸ“‰ğŸ“‰ğŸ“‰

//     ğŸ“ˆğŸ“ˆğŸ“ˆ   LIMIT ENTRY: strategy.order()    ğŸ“ˆğŸ“ˆğŸ“ˆ
// strategy.order("Buy Limit",  long=true,  limit=low,  when=goLong)          // Buy Limit set at the low of signal.
// strategy.order("Sell Limit", long=false, limit=high, when=goShort)         // Sell Limit set at the high of signal.
//     ğŸ“‰ğŸ“‰ğŸ“‰                                     ğŸ“‰ğŸ“‰ğŸ“‰

// ğŸ¯


// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
// ğŸ¹                    Visualizing Pending Orders.
// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
// It's no doubt that TV has some of the most visually appealing charting software out there.
// Drawing from that, I'm going to assume you are a visual learner, much like myself.
// So let's use some plotting techniques so we can visualize just where our pending orders are.

// The following examples are used for a long only strategy, but can easily be reversed
//     ğŸ“ˆğŸ“ˆğŸ“ˆ   Visualizing Pending Orders: Bad Example 1    ğŸ“ˆğŸ“ˆğŸ“ˆ
// limitPrice = low    // Buy Limit Price
// strategy.entry("Buy Limit",  long=true,  limit=limitPrice, when=goLong)       // Buy Limit
// strategy.close("Buy Limit", when=goShort)
// plot(limitPrice)    // Plotting the limitPrice like this won't work because our variable is redefined on each bar.
//     ğŸ“‰ğŸ“‰ğŸ“‰                                                ğŸ“‰ğŸ“‰ğŸ“‰

//     ğŸ“ˆğŸ“ˆğŸ“ˆ   Visualizing Pending Orders: Good Example 1    ğŸ“ˆğŸ“ˆğŸ“ˆ
// // Note: we can only go Long once in this example, so pyramiding will not work.
// var float limitPrice = na
// if goLong and strategy.position_size <= 0
//     limitPrice := low
//     strategy.entry("Buy Limit",  long=true,  limit=limitPrice)       // Buy Limit

// if goShort
//     strategy.close("Buy Limit")

// plot(limitPrice, style=plot.style_linebr, color=color.green)  // Draw a stepline for each limitPrice
//     ğŸ“‰ğŸ“‰ğŸ“‰                                                ğŸ“‰ğŸ“‰ğŸ“‰


//     ğŸ“ˆğŸ“ˆğŸ“ˆ   Visualizing Pending Orders: Better Example 2    ğŸ“ˆğŸ“ˆğŸ“ˆ
// // Note: we can only go Long once in this example, so pyramiding will not work.
// var float limitPrice = na

// if low <= limitPrice
//     limitPrice := na

// if goLong
//     limitPrice := low
//     strategy.entry("Buy Limit",  long=true,  limit=limitPrice)       // Buy Limit

// if goShort
//     strategy.close("Buy Limit")

// plot(limitPrice, style=plot.style_linebr, color=color.green)  // Draw a stepline for each limitPrice
// //     ğŸ“‰ğŸ“‰ğŸ“‰                                                ğŸ“‰ğŸ“‰ğŸ“‰

// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
// ğŸ¹                   How to cancel an order
// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
// The functions used for this are pretty straightforward, but I will go over them so that we cover everything
// strategy.cancel(id, when)
// strategy.cancel_all(when)

// We can cancel specific pending orders or all pending orders with these two functions.
// It's also possible to cancel market orders if the cancel function is called before the market order is sent.

//     ğŸ“ˆğŸ“ˆğŸ“ˆ    Order counts: Canceling a Buy Stop    ğŸ“ˆğŸ“ˆğŸ“ˆ
// i_buyStopPrice  = input(20)

// // Stop orders will be active on every bar
// strategy.entry("Buy Stop",   long=true,    stop=i_buyStopPrice)

// if strategy.position_size > 0
//     // strategy.cancel("Buy Stop")      // Stop Order is cancelled.
//     // strategy.cancel_all()
//     i_buyStopPrice := na

// plot(i_buyStopPrice, title="Buy Stop",   color=color.green)
//     ğŸ“‰ğŸ“‰ğŸ“‰                           ğŸ“‰ğŸ“‰ğŸ“‰


//     ğŸ“ˆğŸ“ˆğŸ“ˆ    Order counts: Canceling Wrong    ğŸ“ˆğŸ“ˆğŸ“ˆ
// // Two things are happening here.
// // 1: A buy stop will always be in place until it is finally triggered
// // 2: After it is triggered, the instruction above it will actually change the buy stop to a market order
// // 3rd: No orders are actually cancelled in the making of this film.

// i_buyStopPrice  = input(20)

// if strategy.position_size > 0
//     strategy.cancel("Buy Stop")
//     i_buyStopPrice := na

// // Stop orders will always be active.
// strategy.entry("Buy Stop",   long=true,    stop=i_buyStopPrice)
// strategy.cancel("Buy Stop")


// plot(i_buyStopPrice, title="Buy Stop",   color=color.green)
//     ğŸ“‰ğŸ“‰ğŸ“‰                           ğŸ“‰ğŸ“‰ğŸ“‰

-------------------------------------------------------------

// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
// ğŸ¹               How to place a Take Profit
// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
// ğŸ“š A Take Profit (T/P) is a type of pending order that specifies the exact price at which to close out an open position for a profit.
// ğŸ“š If the market price does not reach the TP price, the take-profit order does not get filled.
// https://www.investopedia.com/terms/t/take-profitorder.asp

// We can place take profit orders by using the "stop" and "limit" arguments with strategy.exit() or strategy.order()
// Syntax for strategy.exit()
// strategy.exit(id, from_entry, qty, qty_percent, profit, limit, loss, stop, trail_price,
//               trail_points, trail_offset, oca_name, comment, when, alert_message)

//    ğŸ“ˆğŸ“ˆğŸ“ˆ   Example 1: Placing a TP based on a Price Level   ğŸ“ˆğŸ“ˆğŸ“ˆ
// i_tp_pct    = input(10.0, title='Take Profit %')/100

// // Use built in variable to show us our entry price. Works well for 1 order, more entries will show an avg.
// tpLevel     = strategy.position_avg_price * (1 + i_tp_pct)
// // The great thing about using the strategy.position_avg_price variable is we will have a nice TP line
// // that will only plot when we want it to. This is because when the market is flat the variable will return "na" which will not plot.

// plot(tpLevel, title="TP Level",color=color.green, style=plot.style_linebr, linewidth=2)

// // Simple Long Entry
// strategy.entry("Go Long", strategy.long, when=goLong)

// // ğŸ‘‡ Method 1: Simple. Use this.
// // strategy.exit(id="TP", from_entry="Go Long", limit=tpLevel)
// // ğŸ‘†


// // // ğŸ‘‡ Method 2A: Complex. Use this if you can't use method 1.
// // if strategy.position_size > 0  // If we don't check this, then an order will be sent every bar
// //     strategy.order(id="TP", long=false, limit=tpLevel, qty=2)
// // // ğŸ‘†

// // // ğŸ‘‡ Method 2B: Complex. Use this if you can't use method 1.
// // if strategy.position_entry_name == 'Go Long'
// //     strategy.order(id="TP", long=false, limit=tpLevel)
// // // ğŸ‘†


// // // ğŸ‘‡ Method 3: Really Complex. Make the strategy long only and sending a short order, which will convert to a close. Why would you do this?
// // strategy.risk.allow_entry_in(strategy.direction.long)
// // if strategy.position_size > 0
// //     strategy.entry(id="TP", long=false, limit=tpLevel)
// // // ğŸ‘†

// // // ğŸ‘‡ Method 4: Works, kinda, but remember it's a market exit. Notice how this doesn't execute until the next bar.
// // if high >= tpLevel
// //     strategy.close("Go Long")
// // // ğŸ‘†

//    ğŸ“‰ğŸ“‰ğŸ“‰                                                                ğŸ“‰ğŸ“‰ğŸ“‰



//    ğŸ“ˆğŸ“ˆğŸ“ˆ   Example 2: Placing A TP Using Ticks.    ğŸ“ˆğŸ“ˆğŸ“ˆ
// plot(syminfo.mintick, title="min tick helper")   // This is to help identify minticks as each asset is different.
// i_tp_ticks    = input(1200, title='Take Profit In Ticks')

// tpLevel       = strategy.position_avg_price + (i_tp_ticks * syminfo.mintick)  // Note: if we don't use syminfo.mintick our plot will be off.
// plot(tpLevel, title="TP Level",color=color.green, style=plot.style_linebr, linewidth=2)


// strategy.entry("Go Long", strategy.long, when=goLong)           // Simple Long Entry

// // ğŸ‘‡ Method 1: Simple. Use this.
// // strategy.exit(id="TP", from_entry="Go Long", profit=i_tp_ticks)  // The profit argument automatically converts the our input to ticks.
// // ğŸ‘†


// // ğŸ‘‡ Method 2: Complex. Use this if you can't use method 1. Notice the differnet tick variable from Method 1.
// if strategy.position_size > 0  // If we don't check this, then an order will be sent every bar
//     strategy.order(id="TP", long=false, limit=tpLevel)  // It's also important to note that this order will only close 1 contract by default
// // ğŸ‘†


// ğŸ‘‡ Method 3: Why would you do this?
// strategy.risk.allow_entry_in(strategy.direction.long)  // Only allow long entries, otherwise strategy.entry will reverse position.
// if strategy.position_size > 0
//     strategy.entry(id="TP", long=false, limit=tpLevel)
// // ğŸ‘†

// ğŸ‘‡ Method 4: Works, kinda, but remember it's a market exit. Notice how this doesn't execute until the next bar.
// if high >= tpLevel
//     strategy.close("Go Long")
// // ğŸ‘†
// // A lot of people ask "What's the difference between strategy.close and strategy.exit?"", so ive included this example to show you.
//    ğŸ“‰ğŸ“‰ğŸ“‰                                                                ğŸ“‰ğŸ“‰ğŸ“‰
// ğŸ¯




// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
// ğŸ¹               How to Place a Stop Loss
// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
// ğŸ“š A stop-loss (SL) order is an order to buy or sell a security when it reaches a certain price.
// ğŸ“š Stop-loss orders are designed to limit an investorâ€™s loss on a position.
// ğŸ“š When the price falls below the stop price the order becomes a market order and executes at the next available price.
// https://www.investopedia.com/terms/s/stop-lossorder.asp

// We can place stop loss orders by using the "stop" and "limit" arguments with strategy.exit() or strategy.order()
// NOTE: Do not be confused by the "stop" argument also on strategy.entry() This is not for a stop loss, but for a stop order.

//    ğŸ“ˆğŸ“ˆğŸ“ˆ   Example 1: Long SL with strategy.exit and strategy.order()    ğŸ“ˆğŸ“ˆğŸ“ˆ
// i_sl_pct    = input(10.0, title='Stop Loss %')/100
// slLevel     = strategy.position_avg_price * (1 - i_sl_pct)  // Use built in variable to show us our entry price. Works well for 1 order, more entries will show an avg.
// // slLevel     = strategy.position_avg_price * (1 + i_sl_pct)  // Use built in variable to show us our entry price. Works well for 1 order, more entries will show an avg.


// // The great thing about using the strategy.position_avg_price variable is we will have a nice SL line
// // that will only plot when we want it to. This is because when the market is flat the variable will return "na" which will not plot.
// plot(slLevel, title="TP Level",color=color.red, style=plot.style_linebr, linewidth=2)

// // Simple Long Entry
// strategy.entry("Go Long", strategy.long, when=goLong)
// // strategy.entry("Go Long", strategy.short, when=goLong)

// // // ğŸ‘‡ Method 1: Simple. Use this
// // strategy.exit(id="SLoss", from_entry="Go Long", stop=slLevel)
// // // ğŸ‘†


// // // ğŸ‘‡ Method 2: Complex. Use this if you can't use method 1.
// // if strategy.position_size > 0  // If we don't check this, then an order will be sent every bar
// //     strategy.order(id="SL", long=false, stop=slLevel)
// // // ğŸ‘†


// // ğŸ‘‡ Method 3: Why would you do this?
// // strategy.risk.allow_entry_in(strategy.direction.long)
// // if strategy.position_size > 0
// //     strategy.entry(id="SL", long=false, stop=slLevel)
// // ğŸ‘†

// // ğŸ‘‡ Method 4: Works, kinda, but remember it's a market exit. Notice how this doesn't execute until the next bar.
// // if low <= slLevel
// //     strategy.close("Go Long")
// // ğŸ‘†


//    ğŸ“‰ğŸ“‰ğŸ“‰                                                                ğŸ“‰ğŸ“‰ğŸ“‰
// ğŸ¯




// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
// ğŸ¹                   How to place a Stop-Limit Order
// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
// Our two functions for placing market orders, limit orders and stop orders can also place stop-limit orders.

// strategy.entry(id, long, stop=stopPrice, limit=limitPrice)
// strategy.order(id, long, stop=stopPrice, limit=limitPrice)


// To send a stop-limit order we need to use both stop and limit arguments:

//    ğŸ“ˆğŸ“ˆğŸ“ˆ   Entry Stop-Limit: Example 1    ğŸ“ˆğŸ“ˆğŸ“ˆ

// // ğŸ‘‡ Method 1: If block Long entry
// if goLong
//     stopPrice  = high
//     limitPrice = stopPrice + (30 * syminfo.mintick)
//     strategy.entry(id="Buy Stop-Limit", long=true, stop=stopPrice, limit=limitPrice)
// strategy.close("Buy Stop-Limit", when=goShort)
// // ğŸ‘†


// // ğŸ‘‡ Method 2: Using "when" Short Entry
// stopPrice  = low
// limitPrice = stopPrice - (30 * syminfo.mintick)
// strategy.entry(id="Sell Stop-Limit", long=false, stop=stopPrice, limit=limitPrice, when=goShort)
// strategy.close("Sell Stop-Limit", when=goLong)
// // ğŸ‘†


//     ğŸ“‰ğŸ“‰ğŸ“‰                           ğŸ“‰ğŸ“‰ğŸ“‰


//     ğŸ“ˆğŸ“ˆğŸ“ˆ   Visualizing Stop-limit Orders: Working Example 1    ğŸ“ˆğŸ“ˆğŸ“ˆ
// i_buyStopPrice  = input(20)
// i_buyLimitPrice = input(30)

// // Limit order will always be active.
// strategy.order("Buy Stop-Limit", long=true, stop=i_buyStopPrice, limit=i_buyLimitPrice)

// p_bs = plot(i_buyStopPrice, title="Buy Stop",   color=color.green)
// p_bl = plot(i_buyLimitPrice, title="Buy Limit", color=color.yellow)
// fill(p_bs, p_bl, color.new(color.green, 91),title='Buy Zone' )
//     ğŸ“‰ğŸ“‰ğŸ“‰                                                ğŸ“‰ğŸ“‰ğŸ“‰
// ğŸ¯




// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
// ğŸ¹               How to place a OCO order
// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
// ğŸ“š What is an OCO order?
// â¡A one-cancels-the-other order (OCO) is a pair of conditional orders stipulating that if one order executes,
//  then the other order is automatically canceled. An OCO order often combines a stop order with a limit order
//  on an automated trading platform. When either the stop or limit price is reached and the order executed,
//  the other order automatically gets canceled.
//  Experienced traders use OCO orders to mitigate risk and to enter the market.â¦
// https://www.investopedia.com/terms/o/oco.asp

// OCOs are good for trading breakouts and volatility. They will also keep the order book free of any forgotten orders.
// OCO orders can also be referred to as OCA orders. One-Cancels-All orders can work exactly like OCO orders, but they are not limited to just a pair of orders.
// OCA orders encompass OCO orders. So when placing OCO orders we will use the OCA argument.

// There are three functions that can place oco orders.
// strategy.order(id, long, oca_name="OCA Name", oca_type=strategy.oca.cancel)
// strategy.entry(id, long, oca_name="OCA Name", oca_type=strategy.oca.cancel)
// strategy.exit(id,  oca_name="OCA Name")

// Let's look at some examples on how we can use an OCO.

//    ğŸ“ˆğŸ“ˆğŸ“ˆ   Breakout    ğŸ“ˆğŸ“ˆğŸ“ˆ
// // i_upperBreakPrice   = input(28.5, title="Upper Breakout Level")   // Set your own levels
// // i_lowerBreakPrice   = input(28.4, title="Lower Breakout Level")   // Set your own levels
// i_upperBreakPrice   = high          // Or just use the high
// i_lowerBreakPrice   = low           // and low to get an idea of how things work.
// plot(i_upperBreakPrice, title="Upper Break Price", color=color.green, style=plot.style_stepline, offset=1)
// plot(i_lowerBreakPrice, title="Lower Break Price", color=color.red, style=plot.style_stepline, offset=1)

// // // ğŸ‘‡ Method 1: Using strategy.order
// breakout = time > timestamp(2020, 10, 14, 0,0,0)
// if breakout
//     strategy.order("Upper Break Price", long=true,  stop=i_upperBreakPrice,   oca_name='Breakout', oca_type=strategy.oca.cancel)      // Buy Stop
//     strategy.order("Lower Break Price", long=false, stop=i_lowerBreakPrice,   oca_name='Breakout', oca_type=strategy.oca.cancel)      // Sell Stop

// // // ğŸ‘†


// // ğŸ‘‡ Method 2: Using strategy.entry -- This will only open 1 trade by default unless you increase pyramiding.
// breakout = time > timestamp(2020, 10, 14, 0,0,0)
// if breakout
//     strategy.entry("Upper Break Price", long=true,  stop=i_upperBreakPrice, oca_name='Breakout', oca_type=strategy.oca.cancel)  // Buy Stop
//     strategy.entry("Lower Break Price", long=false, stop=i_lowerBreakPrice, oca_name='Breakout', oca_type=strategy.oca.cancel)  // Sell Stop
// // ğŸ‘†
//    ğŸ“‰ğŸ“‰ğŸ“‰                   ğŸ“‰ğŸ“‰ğŸ“‰


//    ğŸ“ˆğŸ“ˆğŸ“ˆ   Stop Loss and TP For Long: OCO    ğŸ“ˆğŸ“ˆğŸ“ˆ
// i_sl = input(5.0, title='Stop Loss %')/100
// i_tp = input(10.0, title='Take Profit %')/100
// SL = strategy.position_avg_price * (1 - i_sl)
// TP = strategy.position_avg_price * (1 + i_tp)
// plot(SL, color=color.red, style=plot.style_linebr, linewidth=2)
// plot(TP, color=color.green, style=plot.style_linebr, linewidth=2)

// strategy.entry(id="Go Long", long=true, when=goLong)


// // // ğŸ‘‡ Method 1: Simple way without OCO. Normally you would want to do this.
// // strategy.exit(id="Simple Exit", from_entry="Go Long", limit=TP, stop=SL)
// // // ğŸ‘†


// // // ğŸ‘‡ Method 2: Complex way with OCO.
// // if strategy.position_size > 0  // Adding in the strategy.position_size logic makes sure we only send these orders once otherwise we have orders resting
// //     // strategy.order("Stop Loss",   long=false,   stop=SL,  oca_name='SLTP', oca_type=strategy.oca.cancel)
// //     // strategy.order("Take Profit", long=false,   limit=TP, oca_name='SLTP', oca_type=strategy.oca.cancel)
// // // ğŸ‘†

//    ğŸ“‰ğŸ“‰ğŸ“‰                   ğŸ“‰ğŸ“‰ğŸ“‰
// ğŸ¯





// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
// ğŸ¹               How to place a trailing stop
// ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
// What is a trailing Stop?
// A trailing stop is a modification of a typical stop order
// that can be set at a defined percentage or dollar amount away from a security's current market price.
// For a long position, an investor places a trailing stop loss below the current market price.
// For a short position, an investor places the trailing stop above the current market price

// âš¡ A trailing stop is designed to lock in profits or limit losses as a trade moves favorably.
// âš¡ Trailing stops only move if the price moves favorably. Once it moves to lock in a profit or reduce a loss, it does not move back in the other direction.
// âš¡ A trailing stop is a stop order and has the additional option of being a limit order or a market order.
// âš¡ One of the most important considerations for a trailing stop order is whether it will be a percentage or fixed-dollar amount and how by much it will trail the price.
// https://www.investopedia.com/terms/t/trailingstop.asp

// Trailing Stop Syntax in Pine
// Trailing stop functionality can be found in the strategy.exit() function.
// Specifically, there are 3 arguments that allow us to control our trailing stops:
// âš¡ trail_price  = Price at which the trailing stop is activated
// âš¡ trail_points = Ticks from entry at which the trailing stop is activated.
// âš¡ trail_offset = Ticks offset from price after activation

//    ğŸ“ˆğŸ“ˆğŸ“ˆ    Trailing Stop For Long Entry    ğŸ“ˆğŸ“ˆğŸ“ˆ
// testStartYear   = input(2020, "Backtest Start Year")
// testStartMonth  = input(10, "Backtest Start Month")
// testStartDay    = input(08, "Backtest Start Day")
// testType        = input('Points', "Activation Type", options=['Points', 'Price'])
// trailLevel      = input(1.178,  "Trail Price", type=input.float, step=0.0001)
// trailPoints     = input(150, "Trail Points (in ticks)", type=input.integer)
// trailOffset     = input(100, "Trail Offset (in ticks)", type=input.integer)
// testPeriodStart = timestamp(testStartYear, testStartMonth, testStartDay, 0, 0)
// // Courtesy of BTR https://backtest-rookies.com/2018/06/08/tradingview-trailing-stop-mechanics-beware-version-3/

// // For plotting Only**
// var tstop = float(na)
// if strategy.position_size > 0 and high >= (testType == "Price" ? trailLevel : trailPoints*syminfo.mintick + strategy.position_avg_price)
//     tstop := max(high - trailOffset*syminfo.mintick, nz(tstop[1]))
// else
//     tstop := na

// tstopActivationLevel = strategy.position_size > 0 ? (testType == "Price" ? trailLevel : strategy.position_avg_price+(trailPoints*syminfo.mintick)): na
// tstopActivated = high >= tstopActivationLevel
// plot(tstopActivationLevel, title="Trail Price Activation", color=tstopActivated ? color.green: color.new(color.yellow, 90), style=plot.style_linebr)
// plot(strategy.position_size > 0 ? tstop: na, title="Trailing Stop", color=color.red, style=plot.style_linebr, offset=0)
// plot(strategy.position_avg_price, title="Entry Price", color=color.yellow, style=plot.style_linebr)

// // Note: Sometimes the Stop and Activation Level won't plot if they are hit in the same bar.
// longCondition = goLong and (time >= testPeriodStart)
// if longCondition
//     strategy.entry("Go Long", strategy.long)
// strategy.exit("Trailing Stop", "Go Long", trail_points=trailPoints, trail_offset=trailOffset, when=testType == 'Points')
// strategy.exit("Trailing Stop", "Go Long", trail_price=trailLevel,   trail_offset=trailOffset, when=testType == 'Price')
